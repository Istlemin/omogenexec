// Package filestore handles storing and reading arbitrary binary files.
package filestore

import (
	"crypto/sha256"
	"encoding/hex"
	"errors"
	"flag"
	"io/ioutil"
	"os"
	"path/filepath"
)

// ErrInvalidURL is returned when retreiving files with an invalid URL.
var ErrInvalidURL = errors.New("the file storage URL could not be recognized")

var (
	storePath   = flag.String("file_store_path", "/var/lib/omogen/filestore", "The folder to used to store files")
	binPrefix   = []byte("bin:")
	storePrefix = []byte("file:")
)

// Magic prefix for files stored as binary data URLs

// StoreFile stores the given byte strings, returning a hash and URL where the file can be loaded from using GetFile.
func StoreFile(contents []byte) (string, []byte, error) {
	hash := sha256.Sum256(contents)
	hexHash := hex.EncodeToString(hash[:])
	var url []byte
	if len(contents) < 10 {
		url = append(url, binPrefix...)
		url = append(url, contents...)
	} else {
		path := filepath.Join(*storePath, hexHash)
		url = append(url, storePrefix...)
		url = append(url, path...)
		if err := ioutil.WriteFile(path, contents, 0644); err != nil {
			return "", nil, err
		}
		if err := os.Chmod(path, 0644); err != nil {
			return "", nil, err
		}
	}
	return hexHash, url, nil
}

// GetFile retrieves the contents of a file given a URL generated by StoreFile.
func GetFile(url []byte) ([]byte, error) {
	if eq(url, binPrefix, len(binPrefix)) {
		return url[len(binPrefix):], nil
	}
	if eq(url, storePrefix, len(storePrefix)) {
		path := url[len(storePrefix):]
		return ioutil.ReadFile(string(path))
	}
	return nil, ErrInvalidURL
}

func eq(a, b []byte, l int) bool {
	if len(a) < l || len(b) < l {
		return false
	}
	for i := 0; i < l; i++ {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}
